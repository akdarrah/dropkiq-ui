"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const underscore_1=require("../../util/underscore"),expression_1=require("../../render/expression"),assert_1=require("../../util/assert"),lexical_1=require("../../parser/lexical"),forloop_drop_1=require("../../drop/forloop-drop"),re=new RegExp(`^(${lexical_1.identifier.source})\\s+in\\s+`+`(${lexical_1.value.source})`+`(?:\\s+${lexical_1.hash.source})*`+"(?:\\s+(reversed))?"+`(?:\\s+${lexical_1.hash.source})*$`);exports.default={type:"block",parse:function(e,r){const s=re.exec(e.args);let t;assert_1.assert(s,`illegal tag: ${e.raw}`),this.variable=s[1],this.collection=s[2],this.reversed=!!s[3],this.templates=[],this.elseTemplates=[];const o=this.liquid.parser.parseStream(r).on("start",()=>t=this.templates).on("tag:else",()=>t=this.elseTemplates).on("tag:endfor",()=>o.stop()).on("template",e=>t.push(e)).on("end",()=>{throw new Error(`tag ${e.raw} not closed`)});o.start()},render:function*(e,r,s){const t=this.liquid.renderer;let o=yield new expression_1.Expression(this.collection).value(e);if(underscore_1.isArray(o)||(underscore_1.isString(o)&&o.length>0?o=[o]:underscore_1.isObject(o)&&(o=Object.keys(o).map(e=>[e,o[e]]))),!underscore_1.isArray(o)||!o.length)return void(yield t.renderTemplates(this.elseTemplates,e,s));const i=r.offset||0,l=void 0===r.limit?o.length:r.limit;o=o.slice(i,i+l),this.reversed&&o.reverse();const n={forloop:new forloop_drop_1.ForloopDrop(o.length)};e.push(n);for(const r of o){if(n[this.variable]=r,yield t.renderTemplates(this.templates,e,s),s.break){s.break=!1;break}s.continue=!1,n.forloop.next()}e.pop()}};