"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const assert_1=require("../../util/assert"),types_1=require("../../types"),lexical_1=require("../../parser/lexical"),block_mode_1=require("../../context/block-mode"),staticFileRE=/[^\s,]+/,withRE=new RegExp(`with\\s+(${lexical_1.value.source})`);exports.default={parse:function(e){let t=staticFileRE.exec(e.args);t&&(this.staticValue=t[0]),t=lexical_1.value.exec(e.args),t&&(this.value=t[0]),t=withRE.exec(e.args),t&&(this.with=t[1])},render:function*(e,t,s){let i;if(e.opts.dynamicPartials)if(lexical_1.quotedLine.exec(this.value)){const t=this.value.slice(1,-1);i=yield this.liquid._parseAndRender(t,e.getAll(),e.opts,e.sync)}else i=yield new types_1.Expression(this.value).value(e);else i=this.staticValue;assert_1.assert(i,"cannot include with empty filename");const l=e.getRegister("blocks"),r=e.getRegister("blockMode");e.setRegister("blocks",{}),e.setRegister("blockMode",block_mode_1.default.OUTPUT),this.with&&(t[i]=yield new types_1.Expression(this.with).evaluate(e));const a=yield this.liquid._parseFile(i,e.opts,e.sync);e.push(t),yield this.liquid.renderer.renderTemplates(a,e,s),e.pop(),e.setRegister("blocks",l),e.setRegister("blockMode",r)}};