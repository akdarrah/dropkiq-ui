"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const assert_1=require("../../util/assert"),types_1=require("../../types"),lexical_1=require("../../parser/lexical"),tablerowloop_drop_1=require("../../drop/tablerowloop-drop"),re=new RegExp(`^(${lexical_1.identifier.source})\\s+in\\s+`+`(${lexical_1.value.source})`+`(?:\\s+${lexical_1.hash.source})*$`);exports.default={parse:function(e,t){const r=re.exec(e.args);let l;assert_1.assert(r,`illegal tag: ${e.raw}`),this.variable=r[1],this.collection=r[2],this.templates=[];const s=this.liquid.parser.parseStream(t).on("start",()=>l=this.templates).on("tag:endtablerow",()=>s.stop()).on("template",e=>l.push(e)).on("end",()=>{throw new Error(`tag ${e.raw} not closed`)});s.start()},render:function*(e,t,r){let l=(yield new types_1.Expression(this.collection).value(e))||[];const s=t.offset||0,o=void 0===t.limit?l.length:t.limit;l=l.slice(s,s+o);const i=t.cols||l.length,a=this.liquid.renderer,n=new tablerowloop_drop_1.TablerowloopDrop(l.length,i),p={tablerowloop:n};e.push(p);for(let t=0;t<l.length;t++,n.next())p[this.variable]=l[t],0===n.col0()&&(1!==n.row()&&r.write("</tr>"),r.write(`<tr class="row${n.row()}">`)),r.write(`<td class="col${n.col()}">`),yield a.renderTemplates(this.templates,e,r),r.write("</td>");l.length&&r.write("</tr>"),e.pop()}};