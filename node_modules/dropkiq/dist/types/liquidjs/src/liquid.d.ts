import { Context } from './context/context';
import { ITemplate } from './template/itemplate';
import { Render } from './render/render';
import Parser from './parser/parser';
import { ITagImplOptions } from './template/tag/itag-impl-options';
import { LiquidOptions, NormalizedFullOptions } from './liquid-options';
import { FilterImplOptions } from './template/filter/filter-impl-options';
export * from './types';
export declare class Liquid {
    options: NormalizedFullOptions;
    renderer: Render;
    parser: Parser;
    private cache;
    private tokenizer;
    private fs;
    constructor(opts?: LiquidOptions);
    parse(html: string, filepath?: string): ITemplate[];
    _render(tpl: ITemplate[], scope?: object, opts?: LiquidOptions, sync?: boolean): IterableIterator<string>;
    render(tpl: ITemplate[], scope?: object, opts?: LiquidOptions): Promise<string>;
    renderSync(tpl: ITemplate[], scope?: object, opts?: LiquidOptions): string;
    _parseAndRender(html: string, scope?: object, opts?: LiquidOptions, sync?: boolean): IterableIterator<string>;
    parseAndRender(html: string, scope?: object, opts?: LiquidOptions): Promise<string>;
    parseAndRenderSync(html: string, scope?: object, opts?: LiquidOptions): string;
    _parseFile(file: string, opts?: LiquidOptions, sync?: boolean): Generator<Promise<string> | Promise<boolean>, any, string>;
    parseFile(file: string, opts?: LiquidOptions): Promise<ITemplate[]>;
    parseFileSync(file: string, opts?: LiquidOptions): ITemplate[];
    renderFile(file: string, ctx?: object, opts?: LiquidOptions): Promise<string>;
    renderFileSync(file: string, ctx?: object, opts?: LiquidOptions): string;
    _evalValue(str: string, ctx: Context): IterableIterator<any>;
    evalValue(str: string, ctx: Context): Promise<any>;
    evalValueSync(str: string, ctx: Context): any;
    registerFilter(name: string, filter: FilterImplOptions): void;
    registerTag(name: string, tag: ITagImplOptions): void;
    plugin(plugin: (this: Liquid, L: typeof Liquid) => void): void;
    express(): (this: any, filePath: string, ctx: object, cb: (err: Error, html?: string) => void) => void;
    private lookupError;
    /**
     * @deprecated use parseFile instead
     */
    getTemplate(file: string, opts?: LiquidOptions): Promise<ITemplate[]>;
    /**
     * @deprecated use parseFileSync instead
     */
    getTemplateSync(file: string, opts?: LiquidOptions): ITemplate[];
}
