"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const CycleDetector_1=require("./CycleDetector");class DataSchema{constructor(e,t,r){this.schema=e,this.context=t,this.scope=r,this.cycleDetector=new CycleDetector_1.CycleDetector,this.constructedScope=this.constructFakeScopeForArrays()}setCurrentPath(e){return this.currentPath=e,this.currentPath}buildPathSchema(e=[],t=this.context,r=[...this.currentPath]){let s=r.shift();if(s){if(!t[s])throw new Error(`Unable to find "${s}" in the current context`);let c=Object.assign({},t[s],{name:s});switch(e.push(c),c.type){case"ColumnTypes::HasOne":{let t=c.foreign_table_name,s=this.schema[t];if(!s)throw new Error(`Table "${t}" was not found in data schema`);this.buildPathSchema(e,s.methods,r);break}default:if(r.length)throw new Error("Liquid expression extends beyond a terminating node")}}return e}nextOptions(e=this.buildPathSchema(),t=this.context){let r=e[e.length-1];if(!r)return t;let s=r.foreign_table_name;switch(r.type){case"ColumnTypes::HasOne":return this.schema[s].methods;default:return{}}}constructFakeScopeForArrays(e=this.context,t={},r="",s=0){return t._table_name=r,Object.keys(e).forEach(r=>{let c=e[r];if("ColumnTypes::HasOne"==c.type){let e=c.foreign_table_name,a=this.schema[e];if(!a)throw new Error(`Table "${e}" was not found in data schema`);let n=a.methods;try{this.cycleDetector.register(e,s)}catch(e){return t}return t[r]=this.constructFakeScopeForArrays(n,{},e,s+1),this.cycleDetector.unregister(e),t}if("ColumnTypes::HasMany"==c.type){let e=c.foreign_table_name,a=this.schema[e];if(!a)throw new Error(`Table "${e}" was not found in data schema`);let n=a.methods;try{this.cycleDetector.register(e,s)}catch(e){return t}return t[r]=[this.constructFakeScopeForArrays(n,{},e,s+1)],this.cycleDetector.unregister(e),t}}),t}}exports.DataSchema=DataSchema;