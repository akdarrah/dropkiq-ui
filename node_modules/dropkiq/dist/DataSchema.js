"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const CycleDetector_1=require("./CycleDetector"),FilterRegistry_1=require("./FilterRegistry");class DataSchema{constructor(e,t,r){this.schema=e,this.context=t,this.scope=r,this.cycleDetector=new CycleDetector_1.CycleDetector,this.constructedScope=this.constructFakeScopeForArrays(),this.filterRegistry=new FilterRegistry_1.FilterRegistry}setCurrentPath(e){return this.currentPath=e,this.currentPath}buildPathSchema(e=[],t=this.context,r=[...this.currentPath]){let s=r.shift();if(""===s)throw new Error("Liquid is invalid (You likely have too many periods)");if(s){if(!t[s])throw new Error(`Unable to find "${s}" in the current context`);let i=Object.assign({},t[s],{name:s});switch(e.push(i),i.type){case"ColumnTypes::HasOne":{let t=i.foreign_table_name,s=this.schema[t];if(!s)throw new Error(`Table "${t}" was not found in data schema`);this.buildPathSchema(e,s.methods,r);break}default:if(r.length)throw new Error("Liquid expression extends beyond a terminating node")}}return e}nextOptions(e=this.buildPathSchema(),t=this.context){let r=e[e.length-1];if(!r)return t;let s=r.foreign_table_name;switch(r.type){case"ColumnTypes::HasOne":return this.schema[s].methods;default:return{}}}constructFakeScopeForArrays(e=this.context,t={},r="",s=0){return t._table_name=r,Object.keys(e).forEach(r=>{let i=e[r];if("ColumnTypes::HasOne"==i.type){let e=i.foreign_table_name,n=this.schema[e];if(!n)throw new Error(`Table "${e}" was not found in data schema`);let a=n.methods;try{this.cycleDetector.register(e,s)}catch(e){return t}return t[r]=this.constructFakeScopeForArrays(a,{},e,s+1),this.cycleDetector.unregister(e),t}if("ColumnTypes::HasMany"==i.type){let e=i.foreign_table_name,n=this.schema[e];if(!n)throw new Error(`Table "${e}" was not found in data schema`);let a=n.methods;try{this.cycleDetector.register(e,s)}catch(e){return t}return t[r]=[this.constructFakeScopeForArrays(a,{},e,s+1)],this.cycleDetector.unregister(e),t}}),t}}exports.DataSchema=DataSchema;